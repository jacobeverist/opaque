{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Cochin;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
### Results\
\
Our results show that results of skeleton mapping with the junction method.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural
\cf0 The pseudocode describing the axis method mapping approach is shown in algorithm [](#alg:junction_method).  The portion to estimating the motion of all possible splices on the skeleton map is in algorithm [](#alg:motion_skeletons).  The portion devoted to adding the pose to the right skeleton is in algorithm [](#alg:add_skeletons).  The portion regarding generating the skeleton is in algorithm [](#alg:gen_skeletons).\
\
<!--\
\\begin\{algorithm\}\
\\caption\{Junction Method\}       \
\\label\{alg:junction_method\}\
\\begin\{algorithmic\}\
\
\\State $X_0 \\Leftarrow (0,0,0)$\
\\State $k \\Leftarrow 0$\
\\State $m \\Leftarrow 0$\
\\State $S_0 \\Leftarrow \\emptyset $\
\\State $C \\Leftarrow \\emptyset$  \\Comment set of global splices\
\
\\State Sweep forward and capture $I_k$\
\\State Sweep backward and capture $I_\{k+1\}$\
\\State $X_\{k+1\} \\Leftarrow$ \\Call\{overlap\}\{$X_\{k\}, I_\{k\}, I_\{k+1\}, \\varnothing$\}\
\\State\
\\State Members of skeleton set $S_m \\Leftarrow S_m \\cup \\\{0,1\\\}$\
\\State $\\hat\{T\}_\{0:m\}, \\hat\{C\} \\Leftarrow$ \\Call\{genSkeletons\}\{$m,S_\{0:m\}, X_k, I_k$\}\
\\State\
\
\\While \{True\}\
\\State $k \\Leftarrow k + 2$\
\\State Locomotion step forward\
\\State Sweep forward and capture $I_k$\
\\State Sweep backward and capture $I_\{k+1\}$\
\\State $\\hat\{X\}_k \\Leftarrow $\\Call\{overlap\}\{$X_\{k-2\}, I_\{k-2\}, I_k, f$\}\
\\State $X_k \\Leftarrow $\\Call\{motionOnSkeletons\}\{$m,T_\{0:m\}, C, \\hat\{X\}_k, I_k$\}\
\\State $X_\{k+1\} \\Leftarrow $\\Call\{overlap\}\{$X_\{k\}, I_\{k\}, I_\{k+1\}, \\varnothing$\}\
\\State\
\\State $m, S_\{0:m\} \\Leftarrow$ \\Call\{addToSkeletons\}\{$m,S_\{0:m\},T_\{0:m\}, X_k, I_k$\}\
\\State $m, S_\{0:m\} \\Leftarrow$ \\Call\{addToSkeletons\}\{$m,S_\{0:m\},T_\{0:m\}, X_\{k+1\}, I_\{k+1\}$\}\
\
\\State\
\\State $\\hat\{T\}_\{0:m\}, \\hat\{C\} \\Leftarrow$ \\Call\{genSkeletons\}\{$m,S_\{0:m\}, X_k, I_k$\}\
\
\\EndWhile\
\
\\end\{algorithmic\}\
\\end\{algorithm\}\
-->\
\
<!--\
\\begin\{algorithm\}\
\\caption\{Motion Estimation\}       \
\\label\{alg:motion_skeletons\}\
\\begin\{algorithmic\}\
\\Function\{motionOnSkeletons\}\{$m,T_\{0:m\}, C, X_k, I_k$\}\
\
\\State $X_\{best\} \\Leftarrow X_k$\
\\For\{ $\\forall c \\in C$\}\
	\\State $X_k \\Leftarrow $\\Call\{overlapAxis\}\{$\\hat\{X\}_k, I_k, C$\}\
	\\State evaluate $X_k$ and set to $X_\{best\}$ if best\
\\EndFor\
\
\\State \\Return $X_\{best\}$\
\\EndFunction\
\
\\end\{algorithmic\}\
\\end\{algorithm\}\
-->\
\
<!--\
\\begin\{algorithm\}\
\\caption\{Add to Skeletons\}       \
\\label\{alg:add_skeletons\}\
\\begin\{algorithmic\}\
\\Function\{addToSkeletons\}\{$m,S_\{0:m\},T_\{0:m\}, X_k, I_k$\}\
\
\\Comment\{this is a comment\}\
\
\\State $div_k \\Leftarrow$ \\Call\{getPointSoupDivergence\}\{$\\hat\{T\}_\{0:m\}, X_k, I_k$\}\
\\If\{$div_k$\}\
	\\State $m \\Leftarrow m + 1$\
	\\State $S_m \\Leftarrow S_m \\cup \\\{k\\\}$\
\\Else\
	\\State find member skeleton $S_p$\
	\\State $S_p \\Leftarrow S_p \\cup \\\{k\\\}$\
\\EndIf\
\\State \\Return $m, S_\{0:m\}$\
\\EndFunction\
\
\\end\{algorithmic\}\
\\end\{algorithm\}\
-->\
\
\
<!--\
\\begin\{algorithm\}\
\\caption\{Generate Skeletons\}       \
\\label\{alg:gen_skeletons\}\
\\begin\{algorithmic\}\
\\Function\{genSkeletons\}\{$m,S_\{0:m\}, X_k, I_k$\}\
\
\
\\For\{$n = 0$ to $m$ \}\
	\\State $\\hat\{X\}_n \\Leftarrow \\emptyset $\
	\\State $\\hat\{I\}_n \\Leftarrow \\emptyset $\
	\\For\{ $\\forall i \\in S_n$\}\
		\\State $\\hat\{I\}_n \\Leftarrow \\hat\{I\}_n \\cup I_i$\
		\\State $\\hat\{X\}_n \\Leftarrow \\hat\{X\}_n \\cup X_i$\
	\\EndFor\
	\\State $\\hat\{T\}_n, \\hat\{C\}_\{1:j\} \\Leftarrow$ \\Call\{skeletonize\}\{$\\hat\{X\}_n, \\hat\{I\}_n$\}\
\\EndFor\
\
\\State \\Return $\\hat\{T\}_\{0:m\}, \\hat\{C\}_\{0:m\}$\
\
\\EndFunction\
\\end\{algorithmic\}\
\\end\{algorithm\}\
-->\
}