{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Cochin;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 ###Overlap Function\
\
We will explain in detail about how the **overlap** function works.  The objective of the function is to find a geometric transform between the two spatial curves, \\\\(C_a, C_b\\\\), generated from the input posture images, \\\\(I_a, I_b\\\\), given the initial pose \\\\(X_a\\\\) and the action \\\\(A\\\\).  It then returns the result \\\\(X_b\\\\).\
\
The function includes an ICP search to find the tightest overlap between the two spatial curves, but is agnostic about the amount of overlap that occurs.   That is, fully overlapped and partially overlapped curves are equally valid results, so long as the curves have similar tangent angles at each pair of closest points.  The pseudo-code for the function can be seen in algorithm [](#alg:overlap).\
\
\
<!--\
\\begin\{algorithm\}\
\\caption\{Overlap Function\}       \
\\label\{alg:overlap\}\
\\begin\{algorithmic\}\
\
\\State Input values\
\
\\State $X_a \\Leftarrow $ initial pose\
\
\\State $I_a \\Leftarrow $ initial posture image\
\
\\State $I_b \\Leftarrow $ current posture image\
\
\\State $A \\Leftarrow $ action\
\
\\State Compute spatial curves from posture images\
\
\\State $C_a \\Leftarrow \\mathrm\{scurve\}(I_a)$\
\
\\State $C_b \\Leftarrow \\mathrm\{scurve\}(I_b)$\
\
\\State Find closest point $p_a^a$ on $C_a^a$ to $(0,0)$\
\
\\State Find closest point $p_b^b$ on $C_b^b$ to $(0,0)$\
\
\\State Displace point $p_a^a$ on $C_a^a$ by action estimate\
\
\\State Transform $C_b^a$ such that the point $p_b^a$ is the same as $p_a^a$\
\
\\State Given two parameters $u$ and $\\gamma$, for the arc length and orientation of $p_b^a$ on $C_a$\
\\State Perform ICP to find the best $u$ and $\\gamma$.\
\
\\State Convert $u$ and $\\gamma$ into $(x_b^a,y_b^a,\\theta_b^a)$\
\\State Find $X_b^a$\
\\State \\Return $X_b^g$\
\
\\end\{algorithmic\}\
\\end\{algorithm\}\
-->\
\
In each spatial curve, we find the point closest to the local frame's origin, \\\\((0,0)\\\\).  For the curve \\\\(C_a^a\\\\) in the \\\\(O_a\\\\) frame, we find the closest point \\\\(p_a^a\\\\).   Likewise, \\\\(p_b^b\\\\) in the \\\\(O_b\\\\) frame.\
\
Depending on the value of \\\\(A\\\\), we need to displace \\\\(p_a\\\\) along the curve \\\\(C_a\\\\) forwards or backwards or not at all.  This is to give an initial estimate of how far the robot has traveled and the location of \\\\(X_b\\\\).  For our purposes, if \\\\(A = f\\\\), we displace an arc length of \\\\(0.5\\\\).  If \\\\(A = b\\\\), we displace \\\\(-0.5\\\\).  If \\\\(A = \\varnothing\\\\), we don't displace at all.\
\
We then convert the point \\\\(p_a\\\\) from cartesian coordinates to a new tuple, \\\\((u,\\gamma)\\\\), where \\\\(\\gamma\\\\) is the orientation of the tangent angle of \\\\(C_b^a\\\\) at \\\\(p_b^a\\\\), and \\\\(u\\\\) is the arc length of \\\\(p_a\\\\) on \\\\(C_a\\\\).  The ICP problem then becomes a 2 dimensional search space to find the right \\\\(u\\\\) and \\\\(\\gamma\\\\) to achieve the best overlap.\
\
After performing the ICP search algorithm, the resulting \\\\(u\\\\) and \\\\(\\gamma\\\\) can then be converted to a new \\\\(X_b^a\\\\).  This is then converted to the global frame and returns \\\\(X_b^g\\\\) as the result of the overlap function.\
}