{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Cochin;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 ### Results\
\
Our results show that various examples of single path environments will produce usable maps at all stages of the mapping.  The primary source of error occurs from coaxial translational error along the path.  Poses can fall somewhere along the path that is off by some amount.\
\
Regardless if there is a severe positional error of a pose, the resultant map will still be topologically correct.  The axis still indicates the travel trajectory of the robot.  We can also see that the more curve features in the environment the better because this gives salient local minima for the ICP search algorithm to find.  Environments that are straight will produce more error in where the pose is localized since all locations will look equally likely.\
\
![Axis Method Results][axis_results]\
\
[axis_results]: {\field{\*\fldinst{HYPERLINK "scrivlnk://298"}}{\fldrslt axis_results}} width=300px\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural
\cf0 The pseudocode describing the axis method mapping approach is shown in algorithm [](#alg:axis_method).\
<!--\
\\begin\{algorithm\}\
\\caption\{Axis Method\}       \
\\label\{alg:axis_method\}\
\\begin\{algorithmic\}\
\
\\State $X_0 \\Leftarrow (0,0,0)$\
\\State $k \\Leftarrow 0$\
\
\\State Sweep forward and capture $I_k$\
\\State Sweep backward and capture $I_\{k+1\}$\
\\State $X_\{k+1\} = \\mathrm\{overlap\}(X_\{k\}, I_\{k\}, I_\{k+1\}, \\varnothing)$\
\\State generate $C_g$ from $I_0:\{k+1\}$ and $X_0:\{k+1\}$\
\
\\While \{True\}\
\\State $k \\Leftarrow k + 2$\
\\State Locomotion step forward\
\\State Sweep forward and capture $I_k$\
\\State Sweep backward and capture $I_\{k+1\}$\
\\State $\\hat\{X\}_k = \\mathrm\{overlap\}(X_\{k-2\}, I_\{k-2\}, I_k, f)$\
\\State $X_k = \\mathrm\{overlap\\_axis\}(\\hat\{X\}_k, I_k, C_g)$\
\\State $X_\{k+1\} = \\mathrm\{overlap\}(X_\{k\}, I_\{k\}, I_\{k+1\}, \\varnothing)$\
\\State generate $C_g$ from $I_0:\{k+1\}$ and $X_0:\{k+1\}$\
\
\\EndWhile\
\
\\end\{algorithmic\}\
\\end\{algorithm\}\
-->}