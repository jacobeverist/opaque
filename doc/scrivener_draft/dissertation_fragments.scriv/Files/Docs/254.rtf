{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Cochin;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
### In-Place Constraint\
\
The in-place constraint's role is to relate the forward and backward nodes of a single anchor position's probe sweeping.  Ideally, the transform between the two poses would be zero change.  However, our experience with the reference pose errors of Chapters 3 and 4 tell us that errors are always possible and likely.  Therefore, we provide a method of guessing a good in-place constraint, and present our hand-made covariance matrix to approximate the error. \
\
The naive approach would be to have a zero transform for our constraint of two nodes that are in the same place, such that:\
\
<!--\
\\begin\{equation\}\
T_\{01\} = \
\\begin\{bmatrix\}\
x_\{01\} \\\\\
y_\{01\} \\\\\
\\theta_\{01\}\
\\end\{bmatrix\}\
= \
\\begin\{bmatrix\}\
0 \\\\\
0 \\\\\
0\
\\end\{bmatrix\}\
\\end\{equation\}\
-->\
\
However, the difference between the two poses must account for reference pose errors, slipping, and differences in the dynamic generation of their respective GPAC poses.  A clue to making this easier is to recognize that both postures of the forward and backward nodes should occupy the same space, and therefore should not be intersecting the walls of the environment that are likely there.  If we focus on making sure the postures of the snakes overlap each other as well as possible in space, we can compute the best fit transform between the two poses in place.\
\
Again, we use B-splines to compute GPACs for both the forward and backward segment postures in the local coordinates.  We define these to be \\\\(\\beta_0^f(u)\\\\) and \\\\(\\beta_1^b(u)\\\\). However, instead of computing the GPAC pose by \\\\(\\beta_0^f(0.5)\\\\) and \\\\(\\beta_1^b(0.5)\\\\), we find the closest point on the GPACs to the local origin, \\\\(O_k\\\\), discussed in Section [](#sec:ref_stable).  The closest point on the GPAC gives us a point and a direction represented by a pose \\\\(I_k\\\\).  For nodes \\\\(v^f_0\\\\) and \\\\(v^b_1\\\\), this gives us \\\\(I_0\\\\) and \\\\(I_1\\\\) as shown in [](#fig:local_origin).\
\
We find \\\\(u_0\\\\) and \\\\(u_1\\\\) such that:\
\
<!--\
\\begin\{equation\}\
\\beta_0^f(u_0) = I_0\
\\end\{equation\}\
\\begin\{equation\}\
\\beta_1^b(u_1) = I_1\
\\end\{equation\}\
-->\
\
![Point \\\\(I_k\\\\) on Curve \\\\(\\beta_k\\\\) from Local Origin \\\\(O_k\\\\)][fig:local_origin]\
\
[fig:local_origin]: {\field{\*\fldinst{HYPERLINK "scrivlnk://199"}}{\fldrslt 5_local_origin.png}} width=400px\
\
\
Our next step is to perform an iterative closest point (ICP) search of the two GPACs so that they overlap each other as closely as possible.  We use only a single variable search using the angle.  The two curves are placed on top of each other at the poses \\\\(I_0\\\\) and \\\\(I_1\\\\) so that the angles are aligned and the curves are tangent.  The ICP search finds the angular difference between \\\\(I_0\\\\) and \\\\(I_1\\\\) such that the ICP error between the two curves is minimized, shown in [](#fig:inplace_ICP).\
\
That is, we find the angle \\\\(\\theta_v\\\\) that minimizes the ICP cost while satisfying the following invariant condition:\
\
<!--\
\\begin\{equation\}\
I_1 = I_0 +\
\\begin\{bmatrix\}\
0 \\\\\
0 \\\\\
\\theta_v\
\\end\{bmatrix\}\
\\end\{equation\}\
-->\
\
![Iterative Closest Point (ICP), finding angle around \\\\(O_0\\\\) and \\\\(O_1\\\\)][fig:inplace_ICP]\
\
[fig:inplace_ICP]: {\field{\*\fldinst{HYPERLINK "scrivlnk://200"}}{\fldrslt 5_inplace_ICP.png}} width=400px\
\
The result of the search gives us the components of the in-place transform we need for our constraint.  Given the pose of the two nodes at the end of the ICP search, we compute what the geometric transform would be between the two GPAC poses \\\\(\\hat\{P\}_0\\\\) and \\\\(\\hat\{P\}_1\\\\).  That gives us the transform component of the constraint.\
\
Experimentally, we've determined that an effective covariance for the in-place constraint is:\
\
<!--\
\\begin\{equation\}\
C_\{01\} = \
\\begin\{bmatrix\}\
0.05 & 0 & 0 \\\\\
0 & 0.05 & 0 \\\\\
0 & 0 & \\frac\{\\pi\}\{16\}\
\\end\{bmatrix\}\
\\end\{equation\}\
-->\
\
\
This indicates that the translational error is tight and equal in all directions.  However, the angular error is even tighter than in our motion constraint.  Experimentally, this is a very accurate relation between nodes in the pose graph.\
\
<!--\
%Compute B-Spline of segment posture of forward and backward nodes \
%local coordinates, local origin at \\\\)P_\{19\}\\\\)\
%Find closest point on axis to local origin.\
%Place each point on top of and tangent to each other\
%Run ICP algorithm to find correct orientation\
%Compute offset, add covariance, result is constraint\
-->}